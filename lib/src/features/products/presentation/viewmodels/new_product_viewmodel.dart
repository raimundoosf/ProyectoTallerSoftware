import 'package:flutter/material.dart';
import 'package:image_picker/image_picker.dart';
import 'package:flutter_app/src/features/products/domain/entities/product.dart';
import 'package:flutter_app/src/features/products/domain/repositories/products_repository.dart';

class NewProductViewModel extends ChangeNotifier {
  final ProductsRepository _repository;

  NewProductViewModel(this._repository);

  // Form fields
  String name = '';
  String description = '';
  String serviceCategory = '';
  String serviceDuration = '';
  double price = 0.0;
  bool isService = false;

  // non-editable brand link auto-generated by caller
  String brandLink = '';

  List<String> certifications = [];

  /// Toggle a certification in the selected list. If it's already present,
  /// remove it; otherwise add it.
  void toggleCertification(String cert) {
    if (certifications.contains(cert)) {
      certifications.remove(cert);
    } else {
      certifications.add(cert);
    }
    notifyListeners();
  }

  /// Check whether the given certification is currently selected.
  bool hasCertification(String cert) => certifications.contains(cert);
  List<Map<String, dynamic>> metrics = [];

  // traceability points and repair locations (local paths for attached media)
  List<Map<String, dynamic>> traceability = [];
  List<Map<String, dynamic>> repairLocations = [];

  // images: local file paths before upload
  final List<String> _localImagePaths = [];
  List<String> get localImagePaths => List.unmodifiable(_localImagePaths);

  bool _isLoading = false;
  bool get isLoading => _isLoading;

  String? _error;
  String? get error => _error;

  final Map<String, String?> _fieldErrors = {};
  Map<String, String?> get fieldErrors => _fieldErrors;

  final ImagePicker _picker = ImagePicker();
  bool _isPicking = false;

  /// Whether an image picker operation is currently active.
  bool get isPicking => _isPicking;

  /// Maximum number of images allowed for a product.
  int get maxImageCount => 3;

  void setBrandLink(String link) {
    brandLink = link;
    notifyListeners();
  }

  void setIsService(bool v) {
    isService = v;
    notifyListeners();
  }

  Future<void> pickImage() async {
    if (_localImagePaths.length >= 3) return;
    final file = await pickImageFile();
    if (file != null) {
      _localImagePaths.add(file.path);
      notifyListeners();
    }
  }

  /// Pick an image from gallery in a single, guarded operation.
  /// Returns the picked XFile or null if none selected or another pick is active.
  Future<XFile?> pickImageFile() async {
    if (_isPicking) return null;
    _isPicking = true;
    try {
      final file = await _picker.pickImage(source: ImageSource.gallery);
      return file;
    } finally {
      _isPicking = false;
    }
  }

  void removeLocalImageAt(int index) {
    _localImagePaths.removeAt(index);
    notifyListeners();
  }

  void addCertification(String cert) {
    certifications.add(cert);
    notifyListeners();
  }

  void addMetric(Map<String, dynamic> metric) {
    metrics.add(metric);
    notifyListeners();
  }

  void addTracePoint(Map<String, dynamic> point) {
    traceability.add(point);
    notifyListeners();
  }

  void addRepairLocation(Map<String, dynamic> loc) {
    repairLocations.add(loc);
    notifyListeners();
  }

  /// Remove traceability point at [index].
  void removeTracePointAt(int index) {
    if (index >= 0 && index < traceability.length) {
      traceability.removeAt(index);
      notifyListeners();
    }
  }

  /// Remove repair location at [index].
  void removeRepairLocationAt(int index) {
    if (index >= 0 && index < repairLocations.length) {
      repairLocations.removeAt(index);
      notifyListeners();
    }
  }

  bool validate() {
    _fieldErrors.clear();
    if (name.trim().isEmpty) _fieldErrors['name'] = 'Nombre requerido';
    if (description.trim().isEmpty) {
      _fieldErrors['description'] = 'DescripciÃ³n requerida';
    }
    if (isService) {
      if (serviceCategory.trim().isEmpty) {
        _fieldErrors['serviceCategory'] = 'Categoria requerida';
      }
    }
    if (price <= 0) _fieldErrors['price'] = 'Precio debe ser mayor a 0';
    if (_localImagePaths.isEmpty) {
      _fieldErrors['images'] = 'Sube al menos 1 imagen';
    }
    notifyListeners();
    return _fieldErrors.isEmpty;
  }

  Future<bool> publish(String companyId) async {
    if (!validate()) return false;
    _isLoading = true;
    _error = null;
    notifyListeners();
    try {
      final product = Product(
        id: '',
        companyId: companyId,
        name: name,
        description: description,
        price: price,
        serviceCategory: serviceCategory,
        serviceDuration: serviceDuration,
        brandLink: brandLink,
        imageUrls: [],
        certifications: certifications,
        metrics: metrics,
        traceability: traceability,
        repairLocations: repairLocations,
        isService: isService,
      );
      final id = await _repository.createProduct(product, _localImagePaths);
      _isLoading = false;
      notifyListeners();
      if (id.isNotEmpty) {
        // reset form after successful creation
        resetForm();
        return true;
      }
      return false;
    } catch (e) {
      _isLoading = false;
      _error = e.toString();
      notifyListeners();
      return false;
    }
  }

  /// Reset the form to its initial empty state.
  void resetForm() {
    name = '';
    description = '';
    serviceCategory = '';
    serviceDuration = '';
    price = 0.0;
    isService = false;
    // keep brandLink so the non-editable brand display remains tied to the
    // current company (it's not part of the mutable form inputs users edit)
    certifications = [];
    metrics = [];
    traceability = [];
    repairLocations = [];
    _localImagePaths.clear();
    _fieldErrors.clear();
    _error = null;
    notifyListeners();
  }
}
