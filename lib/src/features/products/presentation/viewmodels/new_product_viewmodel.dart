import 'package:flutter/material.dart';
import 'package:image_picker/image_picker.dart';
import 'package:flutter_app/src/features/products/domain/entities/product.dart';
import 'package:flutter_app/src/features/products/domain/repositories/products_repository.dart';

class NewProductViewModel extends ChangeNotifier {
  final ProductsRepository _repository;

  NewProductViewModel(this._repository);

  // Edit mode tracking
  Product? _editingProduct;
  bool get isEditing => _editingProduct != null;

  // Form version key - incrementado cada vez que se resetea el formulario
  int _formVersion = 0;
  int get formVersion => _formVersion;

  // Form fields
  String name = '';
  String description = '';
  String serviceCategory = '';
  String serviceDuration = '';
  double price = 0.0;
  bool isService = false;

  // non-editable brand link auto-generated by caller
  String brandLink = '';

  List<String> certifications = [];

  /// Toggle a certification in the selected list. If it's already present,
  /// remove it; otherwise add it.
  void toggleCertification(String cert) {
    if (certifications.contains(cert)) {
      certifications.remove(cert);
    } else {
      certifications.add(cert);
    }
    notifyListeners();
  }

  /// Check whether the given certification is currently selected.
  bool hasCertification(String cert) => certifications.contains(cert);
  List<Map<String, dynamic>> metrics = [];

  // traceability points and repair locations (local paths for attached media)
  List<Map<String, dynamic>> traceability = [];
  List<Map<String, dynamic>> repairLocations = [];

  // images: local file paths before upload
  final List<String> _localImagePaths = [];
  List<String> get localImagePaths => List.unmodifiable(_localImagePaths);

  bool _isLoading = false;
  bool get isLoading => _isLoading;

  String? _error;
  String? get error => _error;

  final Map<String, String?> _fieldErrors = {};
  Map<String, String?> get fieldErrors => _fieldErrors;

  final ImagePicker _picker = ImagePicker();
  bool _isPicking = false;

  /// Whether an image picker operation is currently active.
  bool get isPicking => _isPicking;

  /// Maximum number of images allowed for a product.
  int get maxImageCount => 3;

  void setBrandLink(String link) {
    brandLink = link;
    notifyListeners();
  }

  void setIsService(bool v) {
    isService = v;
    notifyListeners();
  }

  Future<void> pickImage() async {
    if (_localImagePaths.length >= 3) return;
    final file = await pickImageFile();
    if (file != null) {
      _localImagePaths.add(file.path);
      notifyListeners();
    }
  }

  /// Pick an image from gallery in a single, guarded operation.
  /// Returns the picked XFile or null if none selected or another pick is active.
  Future<XFile?> pickImageFile() async {
    if (_isPicking) return null;
    _isPicking = true;
    try {
      final file = await _picker.pickImage(source: ImageSource.gallery);
      return file;
    } finally {
      _isPicking = false;
    }
  }

  void removeLocalImageAt(int index) {
    _localImagePaths.removeAt(index);
    notifyListeners();
  }

  void addCertification(String cert) {
    certifications.add(cert);
    notifyListeners();
  }

  void addMetric(Map<String, dynamic> metric) {
    metrics.add(metric);
    notifyListeners();
  }

  void addTracePoint(Map<String, dynamic> point) {
    traceability.add(point);
    notifyListeners();
  }

  void addRepairLocation(Map<String, dynamic> loc) {
    repairLocations.add(loc);
    notifyListeners();
  }

  /// Remove traceability point at [index].
  void removeTracePointAt(int index) {
    if (index >= 0 && index < traceability.length) {
      traceability.removeAt(index);
      notifyListeners();
    }
  }

  /// Remove repair location at [index].
  void removeRepairLocationAt(int index) {
    if (index >= 0 && index < repairLocations.length) {
      repairLocations.removeAt(index);
      notifyListeners();
    }
  }

  /// Initialize form for editing an existing product.
  void initForEdit(Product product) {
    _editingProduct = product;
    name = product.name;
    description = product.description;
    serviceCategory = product.serviceCategory;
    serviceDuration = product.serviceDuration;
    price = product.price;
    isService = product.isService;
    brandLink = product.brandLink;
    certifications = List.from(product.certifications);
    metrics = List.from(product.metrics);
    traceability = List.from(product.traceability);
    repairLocations = List.from(product.repairLocations);
    // For images, we keep the existing URLs but clear local paths
    // The UI will need to display existing URLs
    _localImagePaths.clear();
    notifyListeners();
  }

  bool validate() {
    _fieldErrors.clear();
    if (name.trim().isEmpty) _fieldErrors['name'] = 'Nombre requerido';
    if (description.trim().isEmpty) {
      _fieldErrors['description'] = 'Descripción requerida';
    }
    if (isService) {
      if (serviceCategory.trim().isEmpty) {
        _fieldErrors['serviceCategory'] = 'Categoria requerida';
      }
    }
    if (price <= 0) _fieldErrors['price'] = 'Precio debe ser mayor a 0';
    // When editing, allow existing images; otherwise require at least one local image
    if (!isEditing && _localImagePaths.isEmpty) {
      _fieldErrors['images'] = 'Sube al menos 1 imagen';
    }
    notifyListeners();
    return _fieldErrors.isEmpty;
  }

  Future<bool> publish(String companyId) async {
    if (!validate()) return false;
    _isLoading = true;
    _error = null;
    notifyListeners();
    try {
      if (isEditing) {
        // Update existing product
        final updatedProduct = Product(
          id: _editingProduct!.id,
          companyId: _editingProduct!.companyId,
          name: name,
          description: description,
          price: price,
          serviceCategory: serviceCategory,
          serviceDuration: serviceDuration,
          brandLink: brandLink,
          imageUrls: _editingProduct!.imageUrls, // Keep existing URLs for now
          certifications: certifications,
          metrics: metrics,
          traceability: traceability,
          repairLocations: repairLocations,
          isService: isService,
        );
        await _repository.updateProduct(
          _editingProduct!.id,
          updatedProduct,
          _localImagePaths,
        );
        _isLoading = false;
        notifyListeners();
        resetForm();
        return true;
      } else {
        // Create new product
        final product = Product(
          id: '',
          companyId: companyId,
          name: name,
          description: description,
          price: price,
          serviceCategory: serviceCategory,
          serviceDuration: serviceDuration,
          brandLink: brandLink,
          imageUrls: [],
          certifications: certifications,
          metrics: metrics,
          traceability: traceability,
          repairLocations: repairLocations,
          isService: isService,
        );
        final id = await _repository.createProduct(product, _localImagePaths);
        _isLoading = false;
        notifyListeners();
        if (id.isNotEmpty) {
          resetForm();
          return true;
        }
        return false;
      }
    } catch (e) {
      _isLoading = false;
      _error = e.toString();
      notifyListeners();
      return false;
    }
  }

  /// Reset the form to its initial empty state.
  void resetForm() {
    _editingProduct = null;
    name = '';
    description = '';
    serviceCategory = '';
    serviceDuration = '';
    price = 0.0;
    isService = false;
    // keep brandLink so the non-editable brand display remains tied to the
    // current company (it's not part of the mutable form inputs users edit)
    certifications = [];
    metrics = [];
    traceability = [];
    repairLocations = [];
    _localImagePaths.clear();
    _fieldErrors.clear();
    _error = null;
    _formVersion++; // Incrementar versión para forzar reconstrucción del Form
    notifyListeners();
  }

  /// Get existing image URLs when editing.
  List<String> get existingImageUrls => _editingProduct?.imageUrls ?? [];
}
